-- LeetCode #53: Maximum Subarray (Kadane's Algorithm)
-- Fold with list accumulator [current_sum max_sum]

#fn kadane_step :[i32] acc:[i32] x:i32
  v0 :i32 = call get acc 0
  v1 :i32 = call get acc 1
  v2 :i32 = + v0 x
  v3 :i32 = call max v2 x
  v4 :i32 = call max v1 v3
  = [v3 v4]

#fn max_subarray :i32 nums:[i32]
  v0 :i32 = call head nums
  v1 :[i32] = call tail nums
  v2 :[i32] = fold v1 [v0 v0] kadane_step
  v3 :i32 = call get v2 1
  = v3

#test max_sub_basic
  v0 :[i32] = [-2 1 -3 4 -1 2 1 -5 4]
  v1 :i32 = call max_subarray v0
  assert == v1 6

#test max_sub_single
  v0 :[i32] = [1]
  v1 :i32 = call max_subarray v0
  assert == v1 1

#test max_sub_all_negative
  v0 :[i32] = [-3 -2 -1 -4]
  v1 :i32 = call max_subarray v0
  assert == v1 -1

#test max_sub_all_positive
  v0 :[i32] = [1 2 3 4]
  v1 :i32 = call max_subarray v0
  assert == v1 10

#entry
  v0 :[i32] = [-2 1 -3 4 -1 2 1 -5 4]
  v1 :i32 = call max_subarray v0
  log "info" "Max subarray of [-2 1 -3 4 -1 2 1 -5 4] = {0}" v1
  = 0
